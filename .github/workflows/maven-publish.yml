# This workflow will build a package using Maven and publish it to GitHub releases when a tag is pushed
# For more information see: https://github.com/actions/setup-java/blob/main/docs/advanced-usage.md#apache-maven-with-a-settings-path

name: Maven Package and Release

on:
  push:
    branches:
      - main  # Triggers version increment on push to main
    tags:
      - 'v*'  # Triggers on tags like v1.0.0, v2.1.3, etc.
  release:
    types: [created]
  workflow_dispatch:  # Allows manual triggering from GitHub Actions UI

jobs:
  increment-version:
    # Skip if the push was made by the bot or contains [skip ci] (to prevent infinite loop)
    if: |
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      github.event.head_commit.author.name != 'github-actions[bot]' &&
      !contains(github.event.head_commit.message, '[skip ci]')
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to create tags and push changes
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Get latest version tag
      id: get_version
      run: |
        # Get the latest version tag (format: v1.0.0)
        LATEST_TAG=$(git tag -l "v*" | sort -V | tail -n 1)
        
        if [ -z "$LATEST_TAG" ]; then
          # No tags exist, start with v1.0.0
          NEW_VERSION="1.0.0"
          echo "No existing tags found, starting with v1.0.0"
        else
          # Extract version number (remove 'v' prefix)
          VERSION=${LATEST_TAG#v}
          echo "Latest tag: $LATEST_TAG (version: $VERSION)"
          
          # Split version into major.minor.patch
          IFS='.' read -r -a VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          # Increment patch version
          PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "Incremented version: $NEW_VERSION"
        fi
        
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "new_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
    
    - name: Update pom.xml version
      run: |
        NEW_VERSION="${{ steps.get_version.outputs.new_version }}"
        echo "Updating pom.xml version to $NEW_VERSION"
        
        # Update the project version in pom.xml (matches version tag between artifactId and packaging)
        sed -i "/<artifactId>Splash<\/artifactId>/,/<packaging>/s/<version>.*<\/version>/<version>${NEW_VERSION}<\/version>/" pom.xml
        
        # Verify the update was successful by checking if the file was modified
        if ! git diff pom.xml | grep -q "<version>"; then
          echo "Error: pom.xml was not modified. The version update may have failed."
          echo "Current pom.xml content around version tag:"
          grep -A 2 -B 2 "<artifactId>Splash</artifactId>" pom.xml || true
          exit 1
        fi
        
        echo "Successfully updated pom.xml version to $NEW_VERSION"
    
    - name: Configure Git
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
    
    - name: Commit version update
      run: |
        # Check if there are any changes to commit
        git add pom.xml
        if git diff --staged --quiet; then
          echo "Error: No changes detected in pom.xml. Version update may have failed."
          exit 1
        fi
        
        # Commit with [skip ci] to prevent triggering the workflow again
        git commit -m "Bump version to ${{ steps.get_version.outputs.new_version }} [skip ci]"
        echo "Committed version update"
    
    - name: Create and push tag
      run: |
        NEW_TAG="${{ steps.get_version.outputs.new_tag }}"
        
        # Fetch remote tags to check if tag already exists on remote
        git fetch origin --tags --quiet || true
        
        # Verify tag doesn't already exist locally or remotely
        if git rev-parse "$NEW_TAG" >/dev/null 2>&1; then
          echo "Error: Tag $NEW_TAG already exists locally"
          exit 1
        fi
        
        if git ls-remote --tags origin "$NEW_TAG" | grep -q "$NEW_TAG"; then
          echo "Error: Tag $NEW_TAG already exists on remote"
          exit 1
        fi
        
        # Create tag from current HEAD (which includes the version commit)
        git tag -a "$NEW_TAG" -m "Release $NEW_TAG" HEAD
        # Push the commit first, then the tag
        git push origin main
        git push origin "$NEW_TAG"
        echo "Created and pushed tag: $NEW_TAG"

  build-and-release:
    # Only run on tag pushes, releases, or manual dispatch (not on branch pushes)
    if: github.event_name == 'release' || github.event_name == 'workflow_dispatch' || (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/'))
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to create/update releases and upload assets
      packages: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for tags
    
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
        server-id: github # Value of the distributionManagement/repository/id field of the pom.xml
        settings-path: ${{ github.workspace }} # location for the settings.xml file

    - name: Build with Maven
      run: mvn -B package --file pom.xml

    - name: Get tag name
      id: tag
      run: |
        if [ "${{ github.event_name }}" == "push" ] && [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" == "release" ]; then
          echo "tag_name=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
        else
          echo "tag_name=" >> $GITHUB_OUTPUT
        fi

    - name: Find JAR file
      id: find_jar
      run: |
        JAR_FILE=$(find target -name "*.jar" -not -name "*-sources.jar" -not -name "*-javadoc.jar" | head -n 1)
        if [ -z "$JAR_FILE" ]; then
          echo "Error: JAR file not found in target directory"
          exit 1
        fi
        echo "jar_file=$JAR_FILE" >> $GITHUB_OUTPUT
        echo "jar_name=$(basename $JAR_FILE)" >> $GITHUB_OUTPUT
        echo "Found JAR: $JAR_FILE"

    - name: Create or Update Release
      if: steps.tag.outputs.tag_name != ''
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.tag.outputs.tag_name }}
        name: Release ${{ steps.tag.outputs.tag_name }}
        files: ${{ steps.find_jar.outputs.jar_file }}
        draft: false
        prerelease: ${{ contains(steps.tag.outputs.tag_name, '-') || contains(steps.tag.outputs.tag_name, 'alpha') || contains(steps.tag.outputs.tag_name, 'beta') || contains(steps.tag.outputs.tag_name, 'rc') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Publish to GitHub Packages Apache Maven
      if: github.event_name == 'release'
      run: mvn deploy --file pom.xml -s $GITHUB_WORKSPACE/settings.xml -Dgithub.repository=${{ github.repository }}
      env:
        GITHUB_TOKEN: ${{ github.token }}
